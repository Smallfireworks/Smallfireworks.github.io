[{"content":"完成了査老师（离线版）的制作，我的博客也是有用起来了。html版査老师，点击即可查看，但加载缓慢，不建议使用，可以直接使用下面的。\n× 请输入教师姓名、拼音或选择学院以开始查询。\n© 2025 by Small fireworks. For offline backup and reference only.\n注：评分、热度及GPA等指标来源于原始数据文件，仅供参考。\n▲ ","date":"2025-07-30T21:38:00+08:00","permalink":"https://smallfireworks.github.io/p/%E6%9F%BB%E8%80%81%E5%B8%88%E7%A6%BB%E7%BA%BF%E7%89%88/","title":"査老师（离线版）"},{"content":"核心概念 在开始之前，我们需要了解两个基本概念（以下皆以github为例）：\n本地仓库 (Local Repository): 这是你计算机上存储项目代码的文件夹。 远程仓库 (Remote Repository): 这是托管在 GitHub 服务器上的项目代码版本。 我们的目标是将这两个仓库链接起来，以便你可以将本地的更改推送到 GitHub，或者从 GitHub 上拉取他人的更改。\n将本地文件夹链接到 GitHub 仓库教程 本教程将引导你完成将本地项目文件夹与你的 GitHub 仓库连接的完整过程。\n第一步：初始化本地仓库 首先，你需要在你的本地项目文件夹中初始化一个新的 Git 仓库。直接在所在文件夹路径栏输入cmd打开命令行工具即可。\n命令:\n1 git init 解释:\ngit init 命令会在你当前的文件夹中创建一个名为 .git 的隐藏子文件夹。 这个 .git 文件夹包含了 Git 仓库运行所需的所有元数据和对象数据库。 可以把这个步骤看作是“激活”你文件夹的 Git 功能，让 Git 开始追踪这个文件夹里的文件变化。 第二步：创建并添加文件到暂存区 接下来，你需要告诉 Git 你想要追踪哪些文件。GitHub 的示例代码中创建了一个 README.md 文件，这是一个很好的起点，因为它可以用来向其他人介绍你的项目。\n命令:\n1 2 echo \u0026#34;# 你的项目名称\u0026#34; \u0026gt;\u0026gt; README.md git add README.md 解释:\necho \u0026quot;# 你的项目名称\u0026quot; \u0026gt;\u0026gt; README.md 这行命令会创建一个名为 README.md 的文件，并在其中写入 # 你的项目名称 这行内容。# 在 Markdown 语法中表示一级标题。 git add README.md 命令会将 README.md 文件添加到 Git 的暂存区 (Staging Area)。 暂存区是一个中间区域，它记录了你下次想要提交到仓库的文件快照。 你可以多次使用 git add 将不同的文件添加到暂存区，然后一次性提交它们。 第三步：提交更改到本地仓库 一旦你将文件添加到了暂存区，你就可以将它们提交 (Commit) 到你的本地仓库了。\n命令:\n1 git commit -m \u0026#34;first commit\u0026#34; 解释:\ngit commit 命令会将在暂存区的文件永久地保存到你的本地仓库的 .git 文件夹中。 -m \u0026quot;first commit\u0026quot; 是一个提交信息 (Commit Message)。 每次提交都应该附带一个有意义的提交信息，用来描述这次提交做了哪些更改。好的提交信息对于团队协作和回顾项目历史至关重要。 第四步：重命名默认分支 为了与当前行业标准保持一致，建议将默认分支命名为 main。\n命令:\n1 git branch -M main 解释:\ngit branch 命令可以用来创建、列出或删除分支。 -M 选项是 -m --force 的简写，它会强制将当前分支重命名为 main。 如果 main 分支已经存在，它也会被覆盖。 第五步：连接到远程仓库 现在，你需要告诉你的本地仓库远程仓库的地址。\n命令:\n1 git remote add origin https://github.com/your-username/your-repository.git 解释:\ngit remote add 命令用于添加一个新的远程仓库。 origin 是你为这个远程仓库起的一个别名。这是一个通用的惯例，用来指代你项目的主要远程仓库。 https://github.com/your-username/your-repository.git 是你的远程仓库的 URL。请将其替换成你自己在 GitHub 上创建的仓库地址。 第六步：将本地更改推送到远程仓库 最后一步，将你本地的 main 分支上的所有提交推送到 GitHub 上的 origin 远程仓库。\n命令:\n1 git push -u origin main 解释:\ngit push 命令用于将本地仓库的提交上传到远程仓库。 origin 指的是你要推送到的远程仓库的别名。 main 指的是你要推送的本地分支。 -u 选项 (或者 --set-upstream) 会在你的本地 main 分支和远程 origin/main 分支之间建立一个跟踪关系。 这样设置之后，你未来再进行推送时，只需要简单地使用 git push 即可，Git 会自动知道你要推送到哪里。 完成以上所有步骤后，你的本地项目文件夹就已经成功链接到了你的 GitHub 仓库。现在你可以在本地进行修改、添加新文件、提交更改，然后使用 git push 将这些更改同步到 GitHub 上。\nGit 日常提交操作教程 在你的本地仓库与 GitHub 远程仓库成功链接之后，日常工作流程通常是：修改文件 -\u0026gt; 添加到暂存区 -\u0026gt; 提交到本地仓库 -\u0026gt; 推送到远程仓库。下面将根据不同情况，详细介绍操作步骤。\n核心概念回顾 工作区 (Working Directory): 你在电脑上能看到的项目文件夹，可以直接在里面修改文件。 暂存区 (Staging Area): 一个临时存放你下次想要提交的文件修改的区域。使用 git add 命令将工作区的修改放入暂存区。 本地仓库 (Local Repository): 保存了项目所有提交历史的地方，位于你的 .git 文件夹中。使用 git commit 将暂存区的内容提交到这里。 远程仓库 (Remote Repository): 托管在 GitHub 上的项目版本。使用 git push 将本地仓库的提交同步到远程仓库。 情况一：提交所有本地更改 这是最常见的情况。你对项目做了多处修改，想要一次性将所有变动（包括新增、修改和删除的文件）都提交。\n场景示例： 你修改了 README.md，同时在项目中新建了一个 new-file.txt 文件。\n操作步骤 查看状态 (可选但推荐) 在进行任何提交前，先检查一下当前仓库的状态是一个好习惯。\n命令:\n1 git status 解释:\n这个命令会列出所有被修改过的、新创建但未被追踪的（untracked）文件。这能帮助你确认将要提交的内容。 你会看到 README.md 显示为 modified，new-file.txt 显示为 untracked。 添加所有更改到暂存区 使用 . 代表当前目录下的所有更改。\n命令:\n1 git add . 解释:\ngit add . 是一个非常方便的命令，它会自动将工作区中所有的新增、修改和删除操作都添加到暂存区。 提交到本地仓库 为这次提交添加一个清晰的描述信息。\n命令:\n1 git commit -m \u0026#34;你的提交信息\u0026#34; 解释:\n-m 后面的字符串是本次提交的说明 (Commit Message)。清晰的说明对于日后回顾代码历史至关重要。 推送到 GitHub 将本地的提交同步到远程仓库。\n命令:\n1 git push 解释:\n因为在初次链接时你已经使用了 -u 参数设置了上游分支 (upstream)，所以之后你不再需要指定 origin main，直接使用 git push 即可。Git 会自动将当前分支的提交推送到与之关联的远程分支。 情况二：只提交特定文件 有时候你可能只完成了某几个文件的修改，不想把其他还在进行中的工作也一并提交。\n场景示例： 你同时修改了 file_A.md 和 file_B.md，但这次只想提交 file_A.md 的修改。\n操作步骤 查看状态 (可选但推荐)\n1 git status 你会看到 file_A.md 和 file_B.md 都被列为 modified。 添加指定文件到暂存区 明确指定要添加的文件名。可以一次添加多个。\n命令:\n1 git add file_A.md 或者如果要一次添加多个指定文件：\n1 git add file_A.md another_file.js 解释:\ngit add \u0026lt;文件名\u0026gt; 命令会将指定的文件放入暂存区，而其他文件（如此处的 file_B.md）则会保持在工作区的修改状态，不会被包含在这次提交中。 提交到本地仓库\n1 2 3 git commit -m \u0026#34;你的提交信息\u0026#34; ``` **解释:** * 这次提交将只包含 `file_A.md` 的快照。 推送到 GitHub\n1 git push 情况三：提交特定文件夹内的所有更改 当你按功能或模块组织文件时，可能需要一次性提交某个文件夹内的所有变动。\n场景示例： 你的项目有一个 assets/images/ 文件夹，你在里面新增和修改了多张图片，希望只提交这个图片文件夹的变动。\n操作步骤 查看状态 (可选但推荐)\n1 git status 检查 assets/images/ 文件夹下的文件是否都已正确显示为已修改或未追踪。 添加指定文件夹到暂存区 指定文件夹的路径。\n命令:\n1 git add assets/images/ 解释:\ngit add \u0026lt;文件夹路径\u0026gt; 会递归地将该文件夹下的所有新增、修改和删除的文件都添加到暂存区。 注意，文件夹路径后面的 / 可加可不加，效果相同。 提交到本地仓库\n1 git commit -m \u0026#34;你的提交信息\u0026#34; 解释:\n本次提交将包含 assets/images/ 文件夹内的所有变动。 推送到 GitHub\n1 git push 通过掌握这几种提交方式，你就可以灵活地管理你的项目版本，保持提交历史的清晰和整洁。\n疑难解答：解决网络问题导致的 push 失败 当你熟练掌握了日常提交操作后，在执行 git push 时，有时可能会遇到网络连接相关的错误，即使你的浏览器可以正常访问 GitHub。本章节将帮助你诊断并解决这类问题。\n问题现象：常见的连接错误 如果你在命令行中看到以下任何一条报错信息，那么你很可能遇到了网络问题：\n1 2 3 4 error: RPC failed; curl 55 Send failure: Connection was reset fatal: the remote end hung up unexpectedly fatal: unable to access \u0026#39;https://github.com/your-username/your-repo.git/\u0026#39;: Recv failure: Connection was reset fatal: unable to access \u0026#39;https://github.com/your-username/your-repo.git/\u0026#39;: Failed to connect to github.com port 443... 问题根源：Git 与系统代理 这个问题的核心原因通常是：命令行中的 Git 工具默认不会自动使用你电脑的系统代理设置。\n你的浏览器：请求 -\u0026gt; 识别并使用系统代理 -\u0026gt; 成功访问 GitHub 你的 Git： 请求 -\u0026gt; 尝试直接连接 (未使用代理) -\u0026gt; 连接超时或被重置，访问 GitHub 失败 当 Git 无法通过直接连接访问远程服务器时，就会产生上述错误。\n解决方案：为 Git 手动配置代理 要解决这个问题，我们只需要明确地告诉 Git 使用哪个代理服务来连接网络即可。\n第一步：找到你的代理端口号 首先，你需要从你的代理软件（如 Clash, V2RayN, Shadowsocks 等）的设置界面中，找到它提供的 HTTP/HTTPS 代理端口。\n这通常在软件的“通用设置”或“端口设置”页面。 常见的端口号有 7890, 7897, 1080 等。 代理服务器地址通常是 127.0.0.1，这是一个指向你电脑本身的固定地址 (也叫 localhost)。 在下面的示例中，我们统一假设查到的代理端口号是 7890。在实际操作时，请务必将其替换为你自己查到的端口号。\n第二步：选择一种配置方式 我们提供两种推荐的配置方式，你可以根据自己的需求选择。\n方式一：临时代理（单次命令，推荐） 如果你只是偶尔需要代理，或者不想修改任何全局配置，这是最干净、最灵活的方法。\n命令:\n1 git -c \u0026#34;http.proxy=http://127.0.0.1:7890\u0026#34; -c \u0026#34;https.proxy=http://127.0.0.1:7890\u0026#34; push 解释:\n-c 参数的作用是为当前这一条 Git 命令临时指定一个配置。 这条命令执行完毕后，代理设置会立即失效，不会对你的系统产生任何永久性影响，非常适合一次性使用。 方式二：全局代理（一劳永逸） 如果你长期在需要代理的网络环境下工作，为 Git 设置一个全局代理会更加方便。\n命令:\n1 2 3 4 5 # 为 Git 设置 HTTP 代理 git config --global http.proxy http://127.0.0.1:7890 # 为 Git 设置 HTTPS 代理 git config --global https.proxy http://127.0.0.1:7890 解释:\n--global 参数表示这个配置对你电脑上所有的 Git 仓库都会生效。 设置完成后，所有需要联网的 Git 命令（如 push, pull, clone）都会自动通过这个代理进行。 如何取消全局代理？\n当你更换到无需代理的网络环境时（例如，在公司内网），可以使用以下命令轻松地清除之前的全局代理设置。\n命令:\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy 通过以上方法，你就可以从容应对因网络环境导致的 git push 失败问题了。\n专题：处理大文件与 Git LFS 在推送代码时，你可能会遇到一个特殊的警告，提示你仓库中的某个文件体积过大。这是 Git 和 GitHub 为了保证仓库性能而设置的限制。本章节将详细解释这个问题，并提供官方推荐的解决方案：Git LFS。\n问题现象：“Large files detected” 警告 当你执行 git push 后，如果看到类似下面的警告信息，就说明你遇到了大文件问题：\n1 2 remote: warning: File assets/videos/demo-video.mp4 is 72.63 MB; this is larger than GitHub\u0026#39;s recommended maximum file size of 50.00 MB remote: warning: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com. 问题根源：\nGit 的设计初衷：Git 是为管理文本文件（如源代码）而设计的，它通过记录每次的文本变动来工作。对于二进制大文件（如视频、设计稿、数据集、压缩包等），Git 无法有效处理其“增量”变化，每次修改都会在历史记录中几乎完整地存一份新的副本。 仓库性能：随着大文件的不断添加和修改，你的 .git 文件夹会迅速膨胀。这会导致克隆 (git clone) 和拉取 (git pull) 仓库变得异常缓慢，严重影响协作效率。 GitHub 的限制：GitHub 建议单个文件不要超过 50MB，并会阻止超过 100MB 的文件推送。 解决方案：Git LFS (Large File Storage) Git LFS 是一个 Git 扩展，专门用于优雅地处理仓库中的大文件。\n工作原理：\n当你使用 Git LFS 追踪一个大文件时，Git 不再将文件本身存储在 .git 历史中。 取而代之的是，它将大文件上传到一个专门的 LFS 服务器（例如 GitHub 的 LFS 存储空间）上。 在你的 Git 仓库中，那个大文件会被替换成一个轻量级的“指针文件”（Pointer File）。这个指针文件是一个小小的文本文件，里面记录了如何从 LFS 服务器上下载回真正的大文件。 好处：\n仓库保持轻量：你的 Git 仓库体积不会因为大文件而膨胀。 历史记录清爽：克隆和拉取速度飞快，因为大家下载的只是代码和轻量级的指针文件。 无缝集成：对于使用者来说，日常的 add, commit, push 等操作几乎没有变化，Git LFS 在后台自动完成所有繁重工作。 如何使用 Git LFS：实践指南 第一步：安装 Git LFS 客户端 这是一个一次性的步骤。你需要先在你的电脑上安装 Git LFS。你可以从官方网站 git-lfs.github.com 下载并安装它。\n第二步：在你的仓库中启用 Git LFS 进入你的本地项目文件夹，运行以下命令。这个命令只需要对每个需要使用 LFS 的仓库执行一次。\n命令:\n1 git lfs install 解释:\n该命令会初始化 Git LFS，并在你的 .git/hooks 目录中设置一些钩子，以便它能自动拦截和处理大文件。 第三步：追踪（Track）大文件 现在，你需要告诉 Git LFS 你希望由它来管理哪些文件或文件类型。\n命令:\n1 2 3 4 5 6 7 8 # 示例：追踪所有 .zip 文件 git lfs track \u0026#34;*.zip\u0026#34; # 示例：追踪某个特定的大文件 git lfs track \u0026#34;assets/data/large-dataset.csv\u0026#34; # 示例：追踪某个文件夹下的所有文件 git lfs track \u0026#34;assets/videos/*\u0026#34; 解释:\ngit lfs track 命令会创建或修改一个名为 .gitattributes 的文件。 这个文件记录了 LFS 的追踪规则，它本身也必须被添加到 Git 仓库中，以确保所有协作者都能遵循相同的规则。 第四步：提交 .gitattributes 文件 命令:\n1 2 git add .gitattributes git commit -m \u0026#34;Configure Git LFS to track large files\u0026#34; 至此，你的仓库已经配置好了。 从现在起，任何符合追踪规则的新增或修改的大文件都会被 Git LFS 自动处理。你可以像操作普通文件一样 git add 和 git commit 它们，然后 git push 即可。\n特别情况：迁移已存在于历史记录中的大文件 如果你在配置 LFS 之前就已经提交过大文件（正如“问题现象”中的场景），那么仅仅开始追踪是不够的。那个大文件依然“藏”在你的历史记录里。你需要一个额外的步骤来清理历史。\n警告： 以下操作会重写你仓库的提交历史。在执行前，请确保你的分支上没有其他人在工作，或者已经和协作者同步了情况。\n操作步骤 确保你已完成上述 LFS 的安装和追踪设置 (install 和 track 命令)。\n使用 migrate 命令迁移历史： 这个命令会检查整个历史记录，并将符合条件的文件转换为 LFS 指针。\n命令:\n1 2 # --include 指定要迁移的文件或模式 git lfs migrate import --include=\u0026#34;assets/videos/demo-video.mp4\u0026#34; 强制推送到远程仓库： 因为历史已被重写，你不能再使用普通的 git push。你需要用 --force 来覆盖远程仓库的历史。\n命令:\n1 git push --force 设置 LFS 后的日常工作流程 一旦你的仓库正确配置了 LFS（无论是新项目还是迁移过的旧项目），日常工作将变得非常简单。\n场景：如何更新或替换一个由 LFS 管理的大文件？\n答案：和操作普通文件完全一样！\n在你的文件夹里：直接用新文件覆盖旧文件，或者删除旧文件再放入新文件。 添加更改到暂存区： 1 git add path/to/your/large-file.zip 提交更改： 1 git commit -m \u0026#34;Update large file to version 2.0\u0026#34; 推送到远程仓库： 1 git push Git LFS 会在后台自动处理指针的更新和新文件的上传，你完全无需关心其中的复杂细节。\n好的，遵照您的要求，我将这一系列的问答和解决方案整合成一个连贯的、全新的教程章节，您可以将其添加到之前内容的末尾。\n高级专题：在 GitHub Pages 上正确使用 Git LFS 当你开始使用 Git LFS 管理大文件后，可能会在将网站部署到 GitHub Pages 时遇到一个棘手的问题：指向大文件的链接失效了，页面上只显示一串奇怪的文本。本章节将深入剖析这个问题，并提供在自动化部署流程中解决该问题的最佳实践。\n问题现象：LFS 文件在线上网站显示为“指针” 场景： 你已经成功地使用 git lfs track 命令来追踪一个大文件（例如一个离线版 HTML 网页、一个高清视频或一个 PDF 文档）。在本地，一切工作正常。但是，当你通过 GitHub Actions 自动部署到 GitHub Pages 后，点击网站上指向该文件的链接，看到的不是文件内容，而是类似下面的一段文本：\n1 2 3 version https://git-lfs.github.com/spec/v1 oid sha256:b4c274dca1c32bc555260155af103e10f2471014ee20808347c808fa13ee60b2 size 76160947 根本原因：部署工作流“不认识”LFS 文件 这个问题的核心在于，你的自动化部署流程（GitHub Actions）在执行时，默认并不会去下载 LFS 跟踪的大文件。\n让我们来梳理一下错误的流程：\n代码检出 (Checkout)：当你的 GitHub Actions 工作流开始运行时，它使用 actions/checkout 步骤来获取你仓库的代码。默认情况下，这个步骤只会下载 LFS 的指针文件（就是你看到的那段文本），而不会下载存储在 LFS 服务器上的真实大文件。 网站构建 (Build)：接下来，你的网站构建工具（如 Hugo, Jekyll, Hexo 等）开始工作。但它拿到的不是真实的大文件，而是那个指针文件。于是，它就把这个指针文件当作了最终内容，并将其打包到了最终的网站文件夹中（例如 public 目录）。 网站部署 (Deploy)：最后，工作流将这个包含了错误内容（指针文件）的 public 文件夹推送到你的 GitHub Pages 仓库。 结果就是，你的线上网站展示的自然就是那个指针文件，链接也就失效了。\n解决方案：让你的工作流支持 LFS 解决方案非常简单，只需在你的自动化部署工作流文件中，明确地告诉 actions/checkout 步骤，在检出代码的同时也要下载 LFS 文件。\n这只需要添加一行配置：lfs: true。\n操作指南 假设你已经有一个用于自动部署的 GitHub Actions 工作流文件，路径为 .github/workflows/deploy.yaml。\n第一步：找到你的部署工作流文件\n打开你的项目，找到并编辑 .github/workflows/deploy.yaml 文件。\n第二步：修改 actions/checkout 步骤\n在文件中找到名为 Checkout 的步骤，它通常看起来像这样：\n修改前：\n1 2 3 4 - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 # 获取所有历史记录，以便Hugo等工具生成.Lastmod等信息 你所需要做的，就是在 with: 下方添加一行 lfs: true。\n修改后：\n1 2 3 4 5 - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 lfs: true # \u0026lt;--- 添加这一行，指示工作流下载LFS跟踪的真实文件 第三步：保存并推送修改\n将修改后的 deploy.yaml 文件提交到你的仓库。\n1 2 3 git add .github/workflows/deploy.yaml git commit -m \u0026#34;Fix: Enable LFS support in deployment workflow\u0026#34; git push 完整示例：一个修正后的跨仓库部署工作流 以下是一个修正后的完整工作流示例，它从源仓库构建，然后部署到一个专门的 GitHub Pages 仓库（例如 your-username.github.io）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # 文件路径: .github/workflows/deploy.yaml name: deploy # 在代码推送到main分支时触发 on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: # 1. 检出代码，并确保LFS文件被正确下载 - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 lfs: true # \u0026lt;-- 关键的修改在这里！ # 2. 设置Hugo环境 (或其他构建工具) - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true # 3. 使用Hugo构建网站，此时它能找到真实的大文件了 - name: Build Web run: hugo -D # 4. 将构建好的网站部署到目标仓库 - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: # 使用仓库的 secrets 来安全地存储访问令牌 PERSONAL_TOKEN: ${{ secrets.YOUR_DEPLOY_TOKEN }} # 部署的目标仓库地址 EXTERNAL_REPOSITORY: your-username/your-username.github.io # 部署到目标仓库的哪个分支 PUBLISH_BRANCH: main # 需要部署的、已构建好的文件夹 PUBLISH_DIR: ./public # 自定义部署的提交信息 commit_message: auto deploy from source repository 验证结果 在你推送了修改后的工作流文件后，GitHub Actions 会自动触发一次新的部署。等待部署完成后，刷新你的 GitHub Pages 网站，再次点击之前失效的链接。\n这一次，由于工作流在构建阶段已经正确下载了真实的大文件，你的网站上链接到的也会是这个真实文件，问题就此解决。你的 Git LFS 文件现在可以完美地在线上展示了。\n","date":"2025-07-29T13:47:00+08:00","permalink":"https://smallfireworks.github.io/p/%E5%85%B3%E4%BA%8Egit/","title":"关于git"},{"content":"把“小说”塞进来。点击即可查看。\n目前共24章。\n","date":"2025-07-22T15:57:00+08:00","permalink":"https://smallfireworks.github.io/p/%E5%B0%8F%E8%AF%B4%E6%B5%8B%E8%AF%95%E4%B8%AD/","title":"小说（测试中）"},{"content":"把之前搞的“大年初三的那一夜”的故事的网页加入本博客。点击即可查看。\n","date":"2025-07-01T00:00:00+08:00","permalink":"https://smallfireworks.github.io/p/%E5%A4%A7%E5%B9%B4%E5%88%9D%E4%B8%89%E7%9A%84%E9%82%A3%E4%B8%80%E5%A4%9C%E5%BE%AE%E6%81%90/","title":"大年初三的那一夜(微恐)"},{"content":"初来乍到，发一个高中的发现的定理。\n定理 设 \\(p\\) 为一个奇素数，\\(a\\) 为一个整数且 \\(1 \\le a \u003c p\\)。记 \\(N\\) 为满足以下两个条件的整数 \\(x\\) 的数量：\n\\(x\\) 是模 \\(p\\) 的二次剩余。 \\(x-a\\) 也是模 \\(p\\) 的二次剩余。 其中 \\(x\\) 的取值范围是 \\(\\{1, 2, \\dots, p-1\\}\\)。\n那么 \\(N\\) 的值可以根据 \\(p\\) 和 \\(a\\) 的性质确定：\n情况一：当 \\(p \\equiv 1 \\pmod 4\\)\n若 \\(a\\) 是模 \\(p\\) 的二次剩余，则 \\(N = \\frac{p-5}{4}\\)。 若 \\(a\\) 是模 \\(p\\) 的二次非剩余，则 \\(N = \\frac{p-1}{4}\\)。 情况二：当 \\(p \\equiv 3 \\pmod 4\\)\n无论 \\(a\\) 是二次剩余还是非剩余，均有 \\(N = \\frac{p-3}{4}\\)。 证明 我们的核心工具是勒让德符号 \\(\\left(\\frac{n}{p}\\right)\\)。对于 \\(n \\not\\equiv 0 \\pmod p\\)，我们知道： \\[ \\frac{1 + \\left(\\frac{n}{p}\\right)}{2} = \\begin{cases} 1 \u0026 \\text{如果 } n \\text{ 是二次剩余} \\\\ 0 \u0026 \\text{如果 } n \\text{ 是二次非剩余} \\end{cases} \\]利用这个性质，我们可以将 \\(N\\) 表示为一个和式。注意求和时需要排除 \\(x=a\\) 的情况，因为此时 \\(x-a=0\\)，不满足条件2。 \\[ N = \\sum_{\\substack{x=1 \\\\ x \\ne a}}^{p-1} \\left( \\frac{1 + \\left(\\frac{x}{p}\\right)}{2} \\right) \\left( \\frac{1 + \\left(\\frac{x-a}{p}\\right)}{2} \\right) \\]为了简化计算，我们先计算一个相关的和 \\(S\\)，其求和范围为完整的 \\(\\{1, 2, \\dots, p-1\\}\\)： \\[ S = \\sum_{x=1}^{p-1} \\left( \\frac{1 + \\left(\\frac{x}{p}\\right)}{2} \\right) \\left( \\frac{1 + \\left(\\frac{x-a}{p}\\right)}{2} \\right) \\] 展开得： \\[ 4S = \\sum_{x=1}^{p-1} \\left( 1 + \\left(\\frac{x}{p}\\right) + \\left(\\frac{x-a}{p}\\right) + \\left(\\frac{x(x-a)}{p}\\right) \\right) \\] \\[ 4S = \\sum_{x=1}^{p-1} 1 + \\sum_{x=1}^{p-1} \\left(\\frac{x}{p}\\right) + \\sum_{x=1}^{p-1} \\left(\\frac{x-a}{p}\\right) + \\sum_{x=1}^{p-1} \\left(\\frac{x(x-a)}{p}\\right) \\]现在我们逐项计算这四个和：\n\\(\\sum_{x=1}^{p-1} 1 = p-1\\)。 \\(\\sum_{x=1}^{p-1} \\left(\\frac{x}{p}\\right) = 0\\)。 (在一个完整剩余系中，二次剩余与非剩余数量相等) \\(\\sum_{x=1}^{p-1} \\left(\\frac{x-a}{p}\\right)\\)。当 \\(x\\) 遍历 \\(\\{1, \\dots, p-1\\}\\) 时，\\(x-a\\) 遍历 \\(\\{1-a, \\dots, p-1-a\\}\\)，这个集合模 \\(p\\) 后恰好是 \\(\\{0, 1, \\dots, p-1\\}\\) 中去掉了 \\(-a\\)。所以和为 \\(\\sum_{y=0}^{p-1}\\left(\\frac{y}{p}\\right) - \\left(\\frac{-a}{p}\\right) = 0 - \\left(\\frac{-a}{p}\\right) = -\\left(\\frac{-a}{p}\\right)\\)。 \\(\\sum_{x=1}^{p-1} \\left(\\frac{x(x-a)}{p}\\right) = -1\\)。这是一个经典的特征和结论。其简要证明如下： \\[ \\sum_{x=1}^{p-1} \\left(\\frac{x(x-a)}{p}\\right) = \\sum_{x=1}^{p-1} \\left(\\frac{x^2(1-ax^{-1})}{p}\\right) = \\sum_{x=1}^{p-1} \\left(\\frac{1-ax^{-1}}{p}\\right) \\] 令 \\(y = x^{-1}\\)，当 \\(x\\) 遍历 \\(\\{1, \\dots, p-1\\}\\) 时，\\(y\\) 也遍历该集合。上式变为： \\[ \\sum_{y=1}^{p-1} \\left(\\frac{1-ay}{p}\\right) \\] 令 \\(z = 1-ay\\)，\\(z\\) 会遍历 \\(\\{1, \\dots, p-1\\}\\) 中除 \\(1\\) 以外的所有元素。因此和为 \\(\\sum_{z=1}^{p-1}\\left(\\frac{z}{p}\\right) - \\left(\\frac{1}{p}\\right) = 0-1 = -1\\)。 将以上结果代入 \\(4S\\) 的表达式： \\[ 4S = (p-1) + 0 - \\left(\\frac{-a}{p}\\right) + (-1) = p - 2 - \\left(\\frac{-a}{p}\\right) \\]和 \\(S\\) 包含了 \\(x=a\\) 这一项的贡献，而我们要求的 \\(N\\) 并不包含。当 \\(x=a\\) 时，\\(\\left(\\frac{x-a}{p}\\right) = 0\\)，该项对 \\(S\\) 的贡献是： \\[ \\left( \\frac{1 + \\left(\\frac{a}{p}\\right)}{2} \\right) \\left( \\frac{1 + 0}{2} \\right) = \\frac{1 + \\left(\\frac{a}{p}\\right)}{4} \\] 所以，\\(S = N + \\frac{1 + \\left(\\frac{a}{p}\\right)}{4}\\)。由此可得 \\(N\\): \\[ N = S - \\frac{1 + \\left(\\frac{a}{p}\\right)}{4} = \\frac{p - 2 - \\left(\\frac{-a}{p}\\right)}{4} - \\frac{1 + \\left(\\frac{a}{p}\\right)}{4} \\] \\[ N = \\frac{p - 3 - \\left(\\frac{a}{p}\\right) - \\left(\\frac{-a}{p}\\right)}{4} \\]这是 \\(N\\) 的通用表达式。现在我们分情况讨论：\n当 \\(p \\equiv 1 \\pmod 4\\)，有 \\(\\left(\\frac{-1}{p}\\right) = 1\\)，因此 \\(\\left(\\frac{-a}{p}\\right) = \\left(\\frac{a}{p}\\right)\\)。 \\[ N = \\frac{p - 3 - 2\\left(\\frac{a}{p}\\right)}{4} \\] 若 \\(a\\) 是二次剩余，\\(\\left(\\frac{a}{p}\\right)=1\\)，则 \\(N = \\frac{p-3-2}{4} = \\frac{p-5}{4}\\)。 若 \\(a\\) 是二次非剩余，\\(\\left(\\frac{a}{p}\\right)=-1\\)，则 \\(N = \\frac{p-3+2}{4} = \\frac{p-1}{4}\\)。 当 \\(p \\equiv 3 \\pmod 4\\)，有 \\(\\left(\\frac{-1}{p}\\right) = -1\\)，因此 \\(\\left(\\frac{-a}{p}\\right) = -\\left(\\frac{a}{p}\\right)\\)。 \\[ N = \\frac{p - 3 - \\left(\\frac{a}{p}\\right) - (-\\left(\\frac{a}{p}\\right))}{4} = \\frac{p-3}{4} \\] 所有情况均已得到验证。证明完毕。\n","date":"2025-06-30T22:10:41+08:00","permalink":"https://smallfireworks.github.io/p/%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0/","title":"初来乍到"}]